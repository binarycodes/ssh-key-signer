---
name: "tagged-release"

on:
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Enter the existing tag name you want to use (e.g., v1.0.0)'
        required: true
        type: string

jobs:

  prepare-release:
    needs: extract-version

    name: "tagged release"
    runs-on: ubuntu-latest

    permissions:
      contents: write

    defaults:
      run:
        working-directory: ./server/

    outputs:
      updated-sha: ${{ steps.get-latest-sha.outputs.updated-sha }}

    steps:
      - name: checkout sources
        uses: actions/checkout@v4

      - name: "display tag name"
        run: |
            echo "using tag name ${{ inputs.tag_name }}"

      - name: set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"

      - name: "update version to tag"
        run: |
          mvn versions:set -DnewVersion=${{ inputs.tag_name }} -DprocessAllModules
          mvn versions:update-properties -DincludeProperties=ssh-signer-common-lib.version
          mvn versions:commit
          git add .

      - name: commit and sign staged changes
        id: get-latest-sha
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_MESSAGE: "chore(automated): Commit multiple files via API"
          BRANCH_NAME: ${{ github.ref }} # The full branch ref (e.g., refs/heads/main)
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.repository }}
        run: |
          # The API requires a list of files that have been staged/changed
          CHANGED_FILES=$(git diff --cached --name-only)
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changes detected. Skipping commit."
            exit 0
          fi

          # Get the latest commit SHA (OID)
          EXPECTED_HEAD_OID=$(git rev-parse HEAD)

          # Build the fileChanges array for the GraphQL mutation
          FILE_ADDITIONS="[]"
          for FILE_PATH in $CHANGED_FILES; do
            # Base64 encode the file contents without line breaks (-w0)
            CONTENT_BASE64=$(base64 -w0 "$FILE_PATH")

            # Escape JSON characters in the path before inserting into JSON array
            ESCAPED_PATH=$(echo "$FILE_PATH" | sed 's/"/\\"/g')

            # Append to the additions array
            FILE_ADDITIONS=$(echo "$FILE_ADDITIONS" | jq --arg path "$ESCAPED_PATH" --arg content "$CONTENT_BASE64" '. += [{path: $path, contents: $content}]')
          done

          # Call the GraphQL API
          gh api graphql \
            -f query=@.github/graphql/createCommit.gql \
            -f owner="$REPO_OWNER" \
            -f repoName="$REPO_NAME" \
            -f branchName="$BRANCH_NAME" \
            -f expectedHeadOid="$EXPECTED_HEAD_OID" \
            -f commitMessage="$COMMIT_MESSAGE" \
            -F fileChanges="{\"additions\": $FILE_ADDITIONS}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create an annotated tag on the current HEAD
          git tag -a "${{ inputs.tag_name }}" -m "Release ${{ inputs.tag_name }}"

          # Push the new tag to the remote
          git push origin "${{ inputs.tag_name }}"

          NEW_SHA=$(git rev-parse main)
          echo "updated-sha=$NEW_SHA" >> $GITHUB_OUTPUT

      - name: prepare commit of new version
        id: get-latest-sha
        run: |
          git add .
          git commit -m "Update version to ${{ inputs.tag_name }}"

          # force move the tag to the new commit
          git tag -f ${{ github.ref_name }}
          git push origin ${{ github.ref_name }} --force

          # merge to main
          git fetch origin
          git switch main
          git merge temp-from-tag --no-ff -m "Merge tag ${{ github.ref_name }} changes into main"

          git push origin main

          # cleanup temp branch
          git branch -d temp-from-tag


      - name: debug the SHA
        run: |
          echo "The SHA exported is: ${{ steps.get-latest-sha.outputs.updated-sha }}"

  docker-build:
    needs: prepare-release
    uses: ./.github/workflows/ssh-key-signer-server-docker.yml
    with:
      sha: ${{ needs.prepare-release.outputs.updated-sha }}
    secrets: inherit

  go-build:
    needs: [extract-version, prepare-release]
    uses: ./.github/workflows/go-build.yml
    with:
      service: go-ssh-keysign
      artifactVersion: ${{ inputs.tag_name }}
      sha: ${{ needs.prepare-release.outputs.updated-sha }}

  create-release:
    needs: [docker-build, go-build]
    runs-on: ubuntu-latest

    steps:
      - name: create release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ github.ref }}  # The tag that triggered the release
          release_name: Release ${{ github.ref }}
          draft: true
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./dist
          pattern: ssh-keysign*

      - name: move downloaded artifacts up
        run: |
          mkdir -p flat-dist
          find dist/ -type f -exec mv {} flat-dist/ \;

      - name: upload artifacts to Release
        uses: softprops/action-gh-release@v2
        with:
          files: ./flat-dist/*
